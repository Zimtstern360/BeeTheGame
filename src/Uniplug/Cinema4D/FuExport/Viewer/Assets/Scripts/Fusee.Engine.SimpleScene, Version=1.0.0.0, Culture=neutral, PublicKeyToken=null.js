/* Generated by JSIL v0.7.8 build 970. See http://jsil.org/ for more information. */ 
var $asm03 = JSIL.DeclareAssembly("Fusee.Engine.SimpleScene, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");

JSIL.DeclareNamespace("Fusee");
JSIL.DeclareNamespace("Fusee.Engine");
JSIL.DeclareNamespace("Fusee.Engine.SimpleScene");
/* class Fusee.Engine.SimpleScene.LightInfo */ 

(function LightInfo$Members () {
  var $, $thisType;
  function LightInfo__ctor () {
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.Object"), 
      Name: "Fusee.Engine.SimpleScene.LightInfo", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [], []), 
      LightInfo__ctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.SimpleScene.SceneRendererExtensions */ 

(function SceneRendererExtensions$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm05.Fusee.Serialization.TransformContainer)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.float4x4)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4x4"), [$asm04.TypeRef("Fusee.Math.float4x4"), $asm04.TypeRef("Fusee.Math.float4x4")], []))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4x4"), [$asm04.TypeRef("Fusee.Math.float3")], []))) ();
  };

  function SceneRendererExtensions_Matrix (tcThis) {
    return $S00().CallStatic($T01(), "op_Multiply", null, 
      $S00().CallStatic($T01(), "op_Multiply", null, 
        $S00().CallStatic($T01(), "op_Multiply", null, 
          $S00().CallStatic($T01(), "op_Multiply", null, 
            $T01().CreateTranslation(tcThis.Translation.MemberwiseClone()), 
            $T01().CreateRotationY(tcThis.Rotation.y)
          ), 
          $T01().CreateRotationX(tcThis.Rotation.x)
        ), 
        $T01().CreateRotationZ(tcThis.Rotation.z)
      ), 
      $S01().CallStatic($T01(), "CreateScale", null, tcThis.Scale.MemberwiseClone())
    );
  };

  JSIL.MakeStaticClass("Fusee.Engine.SimpleScene.SceneRendererExtensions", true, [], function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:true , Public:true }, "Matrix", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4x4"), [$asm05.TypeRef("Fusee.Serialization.TransformContainer")], []), 
      SceneRendererExtensions_Matrix
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.ExtensionAttribute"));

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.ExtensionAttribute"));

})();

/* class Fusee.Engine.SimpleScene.SceneRenderer */ 

(function SceneRenderer$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm05.Fusee.Serialization.SceneContainer)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm02.Fusee.Engine.RenderStateSet)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm01.Fusee.Engine.Blend)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm01.Fusee.Engine.Compare)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.Collections.Generic.List$b1.Of($asm03.Fusee.Engine.SimpleScene.LightInfo))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm05.Fusee.Serialization.MaterialContainer)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm03.Fusee.Engine.SimpleScene.ShaderCodeBuilder)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm07.System.Collections.Generic.List$b1.Of($asm02.Fusee.Engine.EffectParameterDeclaration))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm02.Fusee.Engine.EffectParameterDeclaration)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm04.Fusee.Math.float4x4)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm05.Fusee.Serialization.SceneObjectContainer)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm04.Fusee.Math.AABBf)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm02.Fusee.Engine.RenderContext)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm07.System.Collections.Generic.Dictionary$b2.Of($asm05.Fusee.Serialization.MeshContainer, $asm02.Fusee.Engine.Mesh))) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm07.System.Collections.Generic.Dictionary$b2.Of($asm05.Fusee.Serialization.MaterialContainer, $asm02.Fusee.Engine.ShaderEffect))) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm05.Fusee.Serialization.MatChannelContainer)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm05.Fusee.Serialization.SpecularChannelContainer)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm02.Fusee.Engine.ShaderEffect)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm07.System.IO.Path)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm01.Fusee.Engine.ImageData)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm02.Fusee.Engine.EffectPassDeclaration)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm02.Fusee.Engine.Mesh)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm03.Fusee.Engine.SimpleScene.LightInfo)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm04.Fusee.Math.float4)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm03.Fusee.Engine.SimpleScene.SceneRendererExtensions)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.Collections.Generic.List`1", [$asm03.TypeRef("Fusee.Engine.SimpleScene.LightInfo")]), []))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.Collections.Generic.List`1", [$asm02.TypeRef("Fusee.Engine.EffectParameterDeclaration")]), []))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm02.TypeRef("Fusee.Engine.EffectParameterDeclaration")], []))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.Collections.Generic.Dictionary`2", [$asm05.TypeRef("Fusee.Serialization.MeshContainer"), $asm02.TypeRef("Fusee.Engine.Mesh")]), []))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.Collections.Generic.Dictionary`2", [$asm05.TypeRef("Fusee.Serialization.MaterialContainer"), $asm02.TypeRef("Fusee.Engine.ShaderEffect")]), []))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm04.TypeRef("Fusee.Math.float4x4"), $asm04.TypeRef("Fusee.Math.float4")], []))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4x4"), [$asm04.TypeRef("Fusee.Math.float4x4"), $asm04.TypeRef("Fusee.Math.float4x4")], []))) ();
  };

  function SceneRenderer__ctor (sc, scenePathDirectory) {
    this._stateSet = (new ($T02())()).__Initialize__({
        AlphaBlendEnable: false, 
        SourceBlend: $T03().One, 
        DestinationBlend: $T03().Zero, 
        ZEnable: true, 
        ZFunc: $T04().Less}
    );
    this._lights = $S00().Construct();
    this._sc = sc;
    this._scenePathDirectory = scenePathDirectory;
  };

  function SceneRenderer_AssembleEffectParamers (mc, scb) {
    var effectParameters = $S01().Construct();
    if (mc.get_HasDiffuse()) {
      $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
            Name: scb.get_DiffuseColorName(), 
            Value: mc.Diffuse.Color.MemberwiseClone()}
        ));
      if (mc.Diffuse.Texture !== null) {
        $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
              Name: scb.get_DiffuseMixName(), 
              Value: mc.Diffuse.Mix}
          ));
        $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
              Name: scb.get_DiffuseTextureName(), 
              Value: this.LoadTexture(mc.Diffuse.Texture)}
          ));
      }
    }
    if (mc.get_HasSpecular()) {
      $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
            Name: scb.get_SpecularColorName(), 
            Value: mc.Specular.Color.MemberwiseClone()}
        ));
      $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
            Name: scb.get_SpecularShininessName(), 
            Value: mc.Specular.Shininess}
        ));
      $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
            Name: scb.get_SpecularIntensityName(), 
            Value: mc.Specular.Intensity}
        ));
      if (mc.Specular.Texture !== null) {
        $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
              Name: scb.get_SpecularMixName(), 
              Value: mc.Specular.Mix}
          ));
        $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
              Name: scb.get_SpecularTextureName(), 
              Value: this.LoadTexture(mc.Specular.Texture)}
          ));
      }
    }
    if (mc.get_HasEmissive()) {
      $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
            Name: scb.get_EmissiveColorName(), 
            Value: mc.Emissive.Color.MemberwiseClone()}
        ));
      if (mc.Emissive.Texture !== null) {
        $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
              Name: scb.get_EmissiveMixName(), 
              Value: mc.Emissive.Mix}
          ));
        $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
              Name: scb.get_EmissiveTextureName(), 
              Value: this.LoadTexture(mc.Emissive.Texture)}
          ));
      }
    }
    if (mc.get_HasBump()) {
      $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
            Name: scb.get_BumpIntensityName(), 
            Value: mc.Bump.Intensity}
        ));
      $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
            Name: scb.get_BumpTextureName(), 
            Value: this.LoadTexture(mc.Bump.Texture)}
        ));
    }
    if (!(!mc.get_HasDiffuse() && !mc.get_HasSpecular())) {
      $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
            Name: $T07().get_LightColorName(), 
            Value: $S03().Construct(1, 1, 1)}
        ));
      $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
            Name: $T07().get_LightIntensityName(), 
            Value: 1}
        ));
      $S02().CallVirtual("Add", null, effectParameters, (new ($T09())()).__Initialize__({
            Name: $T07().get_LightDirectionName(), 
            Value: $S03().Construct(0, 0, 1)}
        ));
    }
    return effectParameters;
  };

  function SceneRenderer_get_CurMat () {
    return this._curMat;
  };

  function SceneRenderer_GetAABB () {
    var $temp00;
    var ret = null;
    this._AABBXForm = $T0B().Identity.MemberwiseClone();

    for (var a$0 = this._sc.Children._items, i$0 = 0, l$0 = this._sc.Children._size; i$0 < l$0; ($temp00 = i$0, 
        i$0 = ((i$0 + 1) | 0), 
        $temp00)) {
      var soc = a$0[i$0];
      var nodeBox = this.VisitNodeAABB(soc);
      if (nodeBox !== null) {
        if (ret === null) {
          ret = nodeBox;
        } else {
          ret = $T0D().Union(ret.MemberwiseClone(), nodeBox.MemberwiseClone()).MemberwiseClone();
        }
      }
    }
    return ret;
  };

  function SceneRenderer_InitShaders (rc) {
    if (rc !== this._rc) {
      this._rc = rc;
      this._colorShader = null;
      this._colorParam = null;
      this._textureShader = null;
      this._textureParam = null;
      this._meshMap = $S04().Construct();
      this._matMap = $S05().Construct();
      this._curMat = null;
    }
    if (this._curMat === null) {
      this._curMat = this.MakeMaterial((new ($T06())()).__Initialize__({
            Diffuse: (new ($T11())()).__Initialize__({
                Color: $S03().Construct(0.5, 0.5, 0.5)}
            ), 
            Specular: (new ($T12())()).__Initialize__({
                Color: $S03().Construct(1, 1, 1), 
                Intensity: 0.5, 
                Shininess: 22}
            )}
        ));
      this.get_CurMat().AttachToContext(rc);
    }
  };

  function SceneRenderer_LoadTexture (path) {
    var texturePath = $T14().Combine(this._scenePathDirectory, path);
    var image = this._rc.LoadImage(texturePath).MemberwiseClone();
    return this._rc.CreateTexture(image.MemberwiseClone());
  };

  function SceneRenderer_LookupMaterial (mc) {
    var mat = new JSIL.BoxedVariable(null);
    if (!this._matMap.TryGetValue(mc, /* ref */ mat)) {
      mat.set(this.MakeMaterial(mc));
      mat.get().AttachToContext(this._rc);
      this._matMap.Add(mc, mat.get());
    }
    return mat.get();
  };

  function SceneRenderer_MakeMaterial (mc) {
    var scb = new ($T07())(mc, null);
    var effectParameters = this.AssembleEffectParamers(mc, scb);
    return new ($T13())(JSIL.Array.New($T16(), [(new ($T16())()).__Initialize__({
            VS: scb.get_VS(), 
            PS: scb.get_PS(), 
            StateSet: (new ($T02())()).__Initialize__({
                ZEnable: true, 
                AlphaBlendEnable: false}
            )}
        )]), effectParameters);
  };

  function SceneRenderer_MakeMesh (soc) {
    return (new ($T17())()).__Initialize__({
        Colors: null, 
        Normals: soc.Mesh.Normals, 
        UVs: soc.Mesh.UVs, 
        Vertices: soc.Mesh.Vertices, 
        Triangles: soc.Mesh.Triangles}
    );
  };

  function SceneRenderer_Render (rc) {
    var $temp00;
    this.InitShaders(rc);

    for (var a$0 = this._sc.Children._items, i$0 = 0, l$0 = this._sc.Children._size; i$0 < l$0; ($temp00 = i$0, 
        i$0 = ((i$0 + 1) | 0), 
        $temp00)) {
      var soc = a$0[i$0];
      this.VisitNodeRender(soc);
    }
  };

  function SceneRenderer_RenderWithLights (rm, CurMat) {
    var $temp00;
    if (this._lights.get_Count() > 0) {

      for (var a$0 = this._lights._items, i$0 = 0, l$0 = this._lights._size; i$0 < l$0; ($temp00 = i$0, 
          i$0 = ((i$0 + 1) | 0), 
          $temp00)) {
        var li = a$0[i$0];
        CurMat.RenderMesh(rm);
      }
    } else {
      CurMat.SetEffectParam($T07().get_LightColorName(), $S03().Construct(1, 1, 1));
      var lightDir = ($S06().CallStatic($T0B(), "op_Multiply", null, this._rc.get_InvModelView(), $S07().Construct(0, 0, -1, 0))).get_xyz().MemberwiseClone();
      lightDir.Normalize();
      CurMat.SetEffectParam($T07().get_LightDirectionName(), lightDir.MemberwiseClone());
      CurMat.SetEffectParam($T07().get_LightIntensityName(), 1);
      CurMat.RenderMesh(rm);
    }
  };

  function SceneRenderer_set_CurMat (value) {
    this._curMat = value;
  };

  function SceneRenderer_VisitNodeAABB (soc) {
    var $temp00;
    var ret = null;
    var origMV = this._AABBXForm.MemberwiseClone();
    this._AABBXForm = $S08().CallStatic($T0B(), "op_Multiply", null, this._AABBXForm, $T1A().Matrix(soc.Transform)).MemberwiseClone();
    if (soc.Mesh !== null) {
      ret = $T0D().op_Multiply(this._AABBXForm, soc.Mesh.BoundingBox.MemberwiseClone()).MemberwiseClone();
    }
    if (soc.Children !== null) {

      for (var a$0 = soc.Children._items, i$0 = 0, l$0 = soc.Children._size; i$0 < l$0; ($temp00 = i$0, 
          i$0 = ((i$0 + 1) | 0), 
          $temp00)) {
        var child = a$0[i$0];
        var nodeBox = this.VisitNodeAABB(child);
        if (nodeBox !== null) {
          if (ret === null) {
            ret = nodeBox;
          } else {
            ret = $T0D().Union(ret.MemberwiseClone(), nodeBox.MemberwiseClone()).MemberwiseClone();
          }
        }
      }
    }
    this._AABBXForm = origMV.MemberwiseClone();
    return ret;
  };

  function SceneRenderer_VisitNodeRender (soc) {
    var $temp00;
    var rm = new JSIL.BoxedVariable(null);
    var origMV = this._rc.get_ModelView().MemberwiseClone();
    var origMat = this.get_CurMat();
    if (soc.Material !== null) {
      var mat = this.LookupMaterial(soc.Material);
      this.set_CurMat(mat);
    }
    (this._rc.ModelView = $S08().CallStatic($T0B(), "op_Multiply", null, this._rc.ModelView, $T1A().Matrix(soc.Transform)).MemberwiseClone());
    if (soc.Mesh !== null) {
      if (!this._meshMap.TryGetValue(soc.Mesh, /* ref */ rm)) {
        rm.set($thisType.MakeMesh(soc));
        this._meshMap.Add(soc.Mesh, rm.get());
      }
      if (null !== this.get_CurMat().GetEffectParam($T07().get_LightDirectionName())) {
        this.RenderWithLights(rm.get(), this.get_CurMat());
      } else {
        this.get_CurMat().RenderMesh(rm.get());
      }
    }
    if (soc.Children !== null) {

      for (var a$0 = soc.Children._items, i$0 = 0, l$0 = soc.Children._size; i$0 < l$0; ($temp00 = i$0, 
          i$0 = ((i$0 + 1) | 0), 
          $temp00)) {
        var child = a$0[i$0];
        this.VisitNodeRender(child);
      }
    }
    (this._rc.ModelView = origMV.MemberwiseClone());
    this.set_CurMat(origMat);
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.Object"), 
      Name: "Fusee.Engine.SimpleScene.SceneRenderer", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm05.TypeRef("Fusee.Serialization.SceneContainer"), $.String], []), 
      SceneRenderer__ctor
    );

    $.Method({Static:false, Public:false}, "AssembleEffectParamers", 
      new JSIL.MethodSignature($asm07.TypeRef("System.Collections.Generic.List`1", [$asm02.TypeRef("Fusee.Engine.EffectParameterDeclaration")]), [$asm05.TypeRef("Fusee.Serialization.MaterialContainer"), $asm03.TypeRef("Fusee.Engine.SimpleScene.ShaderCodeBuilder")], []), 
      SceneRenderer_AssembleEffectParamers
    );

    $.Method({Static:false, Public:false}, "get_CurMat", 
      new JSIL.MethodSignature($asm02.TypeRef("Fusee.Engine.ShaderEffect"), [], []), 
      SceneRenderer_get_CurMat
    );

    $.Method({Static:false, Public:true }, "GetAABB", 
      new JSIL.MethodSignature($asm07.TypeRef("System.Nullable`1", [$asm04.TypeRef("Fusee.Math.AABBf")]), [], []), 
      SceneRenderer_GetAABB
    );

    $.Method({Static:false, Public:true }, "InitShaders", 
      new JSIL.MethodSignature(null, [$asm02.TypeRef("Fusee.Engine.RenderContext")], []), 
      SceneRenderer_InitShaders
    );

    $.Method({Static:false, Public:false}, "LoadTexture", 
      new JSIL.MethodSignature($asm01.TypeRef("Fusee.Engine.ITexture"), [$.String], []), 
      SceneRenderer_LoadTexture
    );

    $.Method({Static:false, Public:false}, "LookupMaterial", 
      new JSIL.MethodSignature($asm02.TypeRef("Fusee.Engine.ShaderEffect"), [$asm05.TypeRef("Fusee.Serialization.MaterialContainer")], []), 
      SceneRenderer_LookupMaterial
    );

    $.Method({Static:false, Public:false}, "MakeMaterial", 
      new JSIL.MethodSignature($asm02.TypeRef("Fusee.Engine.ShaderEffect"), [$asm05.TypeRef("Fusee.Serialization.MaterialContainer")], []), 
      SceneRenderer_MakeMaterial
    );

    $.Method({Static:true , Public:false}, "MakeMesh", 
      new JSIL.MethodSignature($asm02.TypeRef("Fusee.Engine.Mesh"), [$asm05.TypeRef("Fusee.Serialization.SceneObjectContainer")], []), 
      SceneRenderer_MakeMesh
    );

    $.Method({Static:false, Public:true }, "Render", 
      new JSIL.MethodSignature(null, [$asm02.TypeRef("Fusee.Engine.RenderContext")], []), 
      SceneRenderer_Render
    );

    $.Method({Static:false, Public:false}, "RenderWithLights", 
      new JSIL.MethodSignature(null, [$asm02.TypeRef("Fusee.Engine.Mesh"), $asm02.TypeRef("Fusee.Engine.ShaderEffect")], []), 
      SceneRenderer_RenderWithLights
    );

    $.Method({Static:false, Public:false}, "set_CurMat", 
      new JSIL.MethodSignature(null, [$asm02.TypeRef("Fusee.Engine.ShaderEffect")], []), 
      SceneRenderer_set_CurMat
    );

    $.Method({Static:false, Public:false}, "VisitNodeAABB", 
      new JSIL.MethodSignature($asm07.TypeRef("System.Nullable`1", [$asm04.TypeRef("Fusee.Math.AABBf")]), [$asm05.TypeRef("Fusee.Serialization.SceneObjectContainer")], []), 
      SceneRenderer_VisitNodeAABB
    );

    $.Method({Static:false, Public:false}, "VisitNodeRender", 
      new JSIL.MethodSignature(null, [$asm05.TypeRef("Fusee.Serialization.SceneObjectContainer")], []), 
      SceneRenderer_VisitNodeRender
    );

    $.Field({Static:false, Public:false}, "_meshMap", $asm07.TypeRef("System.Collections.Generic.Dictionary`2", [$asm05.TypeRef("Fusee.Serialization.MeshContainer"), $asm02.TypeRef("Fusee.Engine.Mesh")])); 
    $.Field({Static:false, Public:false}, "_matMap", $asm07.TypeRef("System.Collections.Generic.Dictionary`2", [$asm05.TypeRef("Fusee.Serialization.MaterialContainer"), $asm02.TypeRef("Fusee.Engine.ShaderEffect")])); 
    $.Field({Static:false, Public:false}, "_sc", $asm05.TypeRef("Fusee.Serialization.SceneContainer")); 
    $.Field({Static:false, Public:false}, "_rc", $asm02.TypeRef("Fusee.Engine.RenderContext")); 
    $.Field({Static:false, Public:false}, "_colorShader", $asm02.TypeRef("Fusee.Engine.ShaderProgram")); 
    $.Field({Static:false, Public:false}, "_colorParam", $asm01.TypeRef("Fusee.Engine.IShaderParam")); 
    $.Field({Static:false, Public:false}, "_textureShader", $asm02.TypeRef("Fusee.Engine.ShaderProgram")); 
    $.Field({Static:false, Public:false}, "_textureParam", $asm01.TypeRef("Fusee.Engine.IShaderParam")); 
    $.Field({Static:false, Public:false}, "_AABBXForm", $asm04.TypeRef("Fusee.Math.float4x4")); 
    $.Field({Static:false, Public:false}, "_lights", $asm07.TypeRef("System.Collections.Generic.List`1", [$asm03.TypeRef("Fusee.Engine.SimpleScene.LightInfo")])); 
    $.Field({Static:false, Public:false}, "_stateSet", $asm02.TypeRef("Fusee.Engine.RenderStateSet")); 
    $.Field({Static:false, Public:false}, "_curMat", $asm02.TypeRef("Fusee.Engine.ShaderEffect")); 
    $.Field({Static:false, Public:false}, "_scenePathDirectory", $.String); 
    $.Property({Static:false, Public:false}, "CurMat", $asm02.TypeRef("Fusee.Engine.ShaderEffect"));

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Engine.SimpleScene.ShaderCodeBuilder */ 

(function ShaderCodeBuilder$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm05.Fusee.Serialization.MaterialContainer)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm05.Fusee.Serialization.MeshContainer)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.System.Text.StringBuilder)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Boolean)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize(System.Array.Of($asm04.Fusee.Math.float3))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize(System.Array.Of($asm04.Fusee.Math.float2))) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.Text.StringBuilder"), []))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Text.StringBuilder"), [$asm07.TypeRef("System.String")], []))) ();
  };

  function ShaderCodeBuilder__ctor (mc, mesh) {
    JSIL.GetType(1);
    this._normalizeNormals = true;
    if (mesh !== null) {
      this.AnalyzeMesh(mesh);
    } else {
      this._hasVertices = (this._hasNormals = (this._hasUVs = true));
    }
    this.AnalyzeMaterial(mc);
    var vs = $S00().Construct();
    this.MeshInputDeclarations(vs);
    this.MatrixDeclarations(vs);
    this.VSBody(vs);
    this._vs = vs.toString();
    var ps = $S00().Construct();
    this.PixelInputDeclarations(ps);
    this.PSBody(ps);
    this._ps = ps.toString();
  };

  function ShaderCodeBuilder_AddCameraVec (ps) {
    $S01().CallVirtual("Append", null, ps, "    vec3 Camera = vViewDir;\n");
  };

  function ShaderCodeBuilder_AddChannelBaseColorCalculation (ps, hasChannelTexture, channelName) {
    if (!(hasChannelTexture && this._hasUVs)) {
      $S01().CallVirtual("Append", null, ps, "    vec3 ");
      $S01().CallVirtual("Append", null, ps, channelName);
      $S01().CallVirtual("Append", null, ps, "BaseColor = ");
      $S01().CallVirtual("Append", null, ps, channelName);
      $S01().CallVirtual("Append", null, ps, "Color;\n");
    } else {
      $S01().CallVirtual("Append", null, ps, "    vec3 ");
      $S01().CallVirtual("Append", null, ps, channelName);
      $S01().CallVirtual("Append", null, ps, "BaseColor = ");
      $S01().CallVirtual("Append", null, ps, channelName);
      $S01().CallVirtual("Append", null, ps, "Color * (1.0 - ");
      $S01().CallVirtual("Append", null, ps, channelName);
      $S01().CallVirtual("Append", null, ps, "Mix) + texture2D(");
      $S01().CallVirtual("Append", null, ps, channelName);
      $S01().CallVirtual("Append", null, ps, "Texture, vUV).rgb * ");
      $S01().CallVirtual("Append", null, ps, channelName);
      $S01().CallVirtual("Append", null, ps, "Mix;\n");
    }
  };

  function ShaderCodeBuilder_AddDiffuseChannel (ps) {
    if (this._hasDiffuse) {
      $S01().CallVirtual("Append", null, ps, "\n\n    //*********** DIFFUSE *********\n");
      this.AddChannelBaseColorCalculation(ps, this._hasDiffuseTexture, "Diffuse");
      $S01().CallVirtual("Append", null, ps, "    float diffFactor = dot(LDir, Normal);\n");
      $S01().CallVirtual("Append", null, ps, "    result += DiffuseBaseColor * LColor * LIntensity * max(diffFactor, 0.0);\n");
    }
  };

  function ShaderCodeBuilder_AddEmissiveChannel (ps) {
    if (this._hasEmissive) {
      $S01().CallVirtual("Append", null, ps, "\n\n    //*********** EMISSIVE *********\n");
      this.AddChannelBaseColorCalculation(ps, this._hasEmissiveTexture, "Emissive");
      $S01().CallVirtual("Append", null, ps, "    result += EmissiveBaseColor;\n");
    }
  };

  function ShaderCodeBuilder_AddLightVec (ps) {
    $S01().CallVirtual("Append", null, ps, "    vec3 LDir = ");
    $S01().CallVirtual("Append", null, ps, $thisType.get_LightDirectionName());
    $S01().CallVirtual("Append", null, ps, ";\n");
    $S01().CallVirtual("Append", null, ps, "    vec3 LColor = ");
    $S01().CallVirtual("Append", null, ps, $thisType.get_LightColorName());
    $S01().CallVirtual("Append", null, ps, ";\n");
    $S01().CallVirtual("Append", null, ps, "    float LIntensity = ");
    $S01().CallVirtual("Append", null, ps, $thisType.get_LightIntensityName());
    $S01().CallVirtual("Append", null, ps, ";\n");
  };

  function ShaderCodeBuilder_AddNormalVec (ps) {
    if (this._hasBump) {
      $S01().CallVirtual("Append", null, ps, "\n\n    //*********** BUMP *********\n");
      $S01().CallVirtual("Append", null, ps, "    vec3 bv =  normalize(texture2D(BumpTexture, vUV).xyz * 2.0 - 1.0);\n");
      $S01().CallVirtual("Append", null, ps, "    bv = vec3(bv.x, bv.y, -bv.z);\n");
      $S01().CallVirtual("Append", null, ps, "    vec3 Normal =  normalize(bv);\n\n");
    } else {
      $S01().CallVirtual("Append", null, ps, "    vec3 Normal = normalize(vNormal);\n");
    }
  };

  function ShaderCodeBuilder_AddSpecularChannel (ps) {
    if (this._hasSpecular) {
      $S01().CallVirtual("Append", null, ps, "\n\n    //*********** SPECULAR *********\n");
      if (!this._hasDiffuse) {
        $S01().CallVirtual("Append", null, ps, "    float diffFactor = dot(LDir, Normal);\n");
      }
      $S01().CallVirtual("Append", null, ps, "    if (diffFactor > 0.0) {\n  ");
      this.AddChannelBaseColorCalculation(ps, this._hasSpecularTexture, "Specular");
      $S01().CallVirtual("Append", null, ps, "      vec3 h = normalize(LDir + Camera);\n");
      $S01().CallVirtual("Append", null, ps, "      result += SpecularBaseColor * LColor * LIntensity * SpecularIntensity * pow(max(0.0, dot(h, Normal)), SpecularShininess);\n");
      $S01().CallVirtual("Append", null, ps, "    }\n");
    }
  };

  function ShaderCodeBuilder_AnalyzeMaterial (mc) {
    this._hasDiffuse = mc.get_HasDiffuse();
    if (this._hasDiffuse) {
      this._hasDiffuseTexture = (mc.Diffuse.Texture !== null);
    }
    this._hasSpecular = mc.get_HasSpecular();
    if (this._hasSpecular) {
      this._hasSpecularTexture = (mc.Specular.Texture !== null);
    }
    this._hasEmissive = mc.get_HasEmissive();
    if (this._hasEmissive) {
      this._hasEmissiveTexture = (mc.Emissive.Texture !== null);
    }
    this._hasBump = mc.get_HasBump();
  };

  function ShaderCodeBuilder_AnalyzeMesh (mesh) {
    this._hasVertices = ((mesh.Vertices !== null) && 
      (mesh.Vertices.length > 0));
    this._hasNormals = ((mesh.Normals !== null) && 
      (mesh.Normals.length > 0));
    this._hasUVs = ((mesh.UVs !== null) && 
      (mesh.UVs.length > 0));
    this._hasColors = false;
  };

  function ShaderCodeBuilder_BumpInputDeclaration (ps) {
    if (this._hasBump) {
      $S01().CallVirtual("Append", null, ps, "  uniform sampler2D BumpTexture;\n");
      $S01().CallVirtual("Append", null, ps, "  uniform float BumpIntensity;\n\n");
    }
  };

  function ShaderCodeBuilder_ChannelInputDeclaration (ps, hasChannel, hasChannelTexture, channelName) {
    if (hasChannel) {
      $S01().CallVirtual("Append", null, ps, "  uniform vec3 ");
      $S01().CallVirtual("Append", null, ps, channelName);
      $S01().CallVirtual("Append", null, ps, "Color;\n");
      if (hasChannelTexture) {
        $S01().CallVirtual("Append", null, ps, "  uniform sampler2D ");
        $S01().CallVirtual("Append", null, ps, channelName);
        $S01().CallVirtual("Append", null, ps, "Texture;\n");
        $S01().CallVirtual("Append", null, ps, "  uniform float ");
        $S01().CallVirtual("Append", null, ps, channelName);
        $S01().CallVirtual("Append", null, ps, "Mix;\n\n");
      }
    }
  };

  function ShaderCodeBuilder_get_BumpIntensityName () {
    return (this._hasBump ? "BumpIntensity" : null);
  };

  function ShaderCodeBuilder_get_BumpTextureName () {
    return (this._hasBump ? "BumpTexture" : null);
  };

  function ShaderCodeBuilder_get_DiffuseColorName () {
    return (this._hasDiffuse ? "DiffuseColor" : null);
  };

  function ShaderCodeBuilder_get_DiffuseMixName () {
    return (this._hasDiffuse ? "DiffuseMix" : null);
  };

  function ShaderCodeBuilder_get_DiffuseTextureName () {
    return (this._hasDiffuseTexture ? "DiffuseTexture" : null);
  };

  function ShaderCodeBuilder_get_EmissiveColorName () {
    return (this._hasEmissive ? "EmissiveColor" : null);
  };

  function ShaderCodeBuilder_get_EmissiveMixName () {
    return (this._hasEmissive ? "EmissiveMix" : null);
  };

  function ShaderCodeBuilder_get_EmissiveTextureName () {
    return (this._hasEmissiveTexture ? "EmissiveTexture" : null);
  };

  function ShaderCodeBuilder_get_LightColorName () {
    return "LightColor";
  };

  function ShaderCodeBuilder_get_LightDirectionName () {
    return "LightDirection";
  };

  function ShaderCodeBuilder_get_LightIntensityName () {
    return "LightIntensity";
  };

  function ShaderCodeBuilder_get_PS () {
    return this._ps;
  };

  function ShaderCodeBuilder_get_SpecularColorName () {
    return (this._hasSpecular ? "SpecularColor" : null);
  };

  function ShaderCodeBuilder_get_SpecularIntensityName () {
    return (this._hasSpecular ? "SpecularIntensity" : null);
  };

  function ShaderCodeBuilder_get_SpecularMixName () {
    return (this._hasSpecular ? "SpecularMix" : null);
  };

  function ShaderCodeBuilder_get_SpecularShininessName () {
    return (this._hasSpecular ? "SpecularShininess" : null);
  };

  function ShaderCodeBuilder_get_SpecularTextureName () {
    return (this._hasSpecularTexture ? "SpecularTexture" : null);
  };

  function ShaderCodeBuilder_get_VS () {
    return this._vs;
  };

  function ShaderCodeBuilder_MatrixDeclarations (vs) {
    if (this._hasSpecular) {
      $S01().CallVirtual("Append", null, vs, "  uniform mat4 FUSEE_IMV;\n");
    }
    $S01().CallVirtual("Append", null, vs, "  uniform mat4 FUSEE_MVP;\n");
  };

  function ShaderCodeBuilder_MeshInputDeclarations (vs) {
    if (this._hasVertices) {
      $S01().CallVirtual("Append", null, vs, "  attribute vec3 fuVertex;\n");
      if (this._hasSpecular) {
        $S01().CallVirtual("Append", null, vs, "  varying vec3 vViewDir;\n");
      }
    }
    if (this._hasNormals) {
      $S01().CallVirtual("Append", null, vs, "  attribute vec3 fuNormal;\n  varying vec3 vNormal;\n");
    }
    if (this._hasUVs) {
      $S01().CallVirtual("Append", null, vs, "  attribute vec2 fuUV;\n  varying vec2 vUV;\n");
    }
    if (this._hasColors) {
      $S01().CallVirtual("Append", null, vs, "  attribute vec4 fuColor;\n  varying vec4 vColors;\n");
    }
  };

  function ShaderCodeBuilder_PixelInputDeclarations (ps) {
    $S01().CallVirtual("Append", null, ps, "#ifdef GL_ES\n");
    $S01().CallVirtual("Append", null, ps, "  precision highp float;\n");
    $S01().CallVirtual("Append", null, ps, "#endif\n\n");
    this.ChannelInputDeclaration(ps, this._hasDiffuse, this._hasDiffuseTexture, "Diffuse");
    this.SpecularInputDeclaration(ps);
    this.ChannelInputDeclaration(ps, this._hasEmissive, this._hasEmissiveTexture, "Emissive");
    this.BumpInputDeclaration(ps);
    if (!(!this._hasSpecular && !this._hasDiffuse)) {
      $S01().CallVirtual("Append", null, ps, "  uniform vec3 ");
      $S01().CallVirtual("Append", null, ps, $thisType.get_LightColorName());
      $S01().CallVirtual("Append", null, ps, ";\n");
      $S01().CallVirtual("Append", null, ps, "  uniform float ");
      $S01().CallVirtual("Append", null, ps, $thisType.get_LightIntensityName());
      $S01().CallVirtual("Append", null, ps, ";\n");
      $S01().CallVirtual("Append", null, ps, "  uniform vec3 ");
      $S01().CallVirtual("Append", null, ps, $thisType.get_LightDirectionName());
      $S01().CallVirtual("Append", null, ps, ";\n");
    }
    if (this._hasSpecular) {
      $S01().CallVirtual("Append", null, ps, "  varying vec3 vViewDir;\n");
    }
    if (this._hasNormals) {
      $S01().CallVirtual("Append", null, ps, "  varying vec3 vNormal;\n");
    }
    if (this._hasUVs) {
      $S01().CallVirtual("Append", null, ps, "  varying vec2 vUV;\n");
    }
  };

  function ShaderCodeBuilder_PSBody (ps) {
    $S01().CallVirtual("Append", null, ps, "\n\n  void main()\n  {\n");
    $S01().CallVirtual("Append", null, ps, "    vec3 result = vec3(0, 0, 0);\n\n");
    this.AddNormalVec(ps);
    this.AddCameraVec(ps);
    this.AddLightVec(ps);
    this.AddEmissiveChannel(ps);
    this.AddDiffuseChannel(ps);
    this.AddSpecularChannel(ps);
    $S01().CallVirtual("Append", null, ps, "\n    gl_FragColor = vec4(result, 1.0);\n");
    $S01().CallVirtual("Append", null, ps, "  }\n\n");
  };

  function ShaderCodeBuilder_SpecularInputDeclaration (ps) {
    if (this._hasSpecular) {
      this.ChannelInputDeclaration(ps, this._hasSpecular, this._hasSpecularTexture, "Specular");
      $S01().CallVirtual("Append", null, ps, "  uniform float SpecularShininess;\n");
      $S01().CallVirtual("Append", null, ps, "  uniform float SpecularIntensity;\n\n");
    }
  };

  function ShaderCodeBuilder_VSBody (vs) {
    $S01().CallVirtual("Append", null, vs, "\n\n  void main()\n  {\n");
    if (this._hasNormals) {
      if (this._normalizeNormals) {
        $S01().CallVirtual("Append", null, vs, "    vNormal = normalize(fuNormal);\n");
      } else {
        $S01().CallVirtual("Append", null, vs, "    vNormal = fuNormal;\n");
      }
    }
    if (this._hasSpecular) {
      $S01().CallVirtual("Append", null, vs, "    vec3 viewPos = FUSEE_IMV[3].xyz;\n");
      $S01().CallVirtual("Append", null, vs, "    vViewDir = normalize(viewPos - fuVertex);\n");
    }
    $S01().CallVirtual("Append", null, vs, "    gl_Position = FUSEE_MVP * vec4(fuVertex, 1.0);\n");
    if (this._hasUVs) {
      $S01().CallVirtual("Append", null, vs, "    vUV = fuUV;\n");
    }
    $S01().CallVirtual("Append", null, vs, "  }\n\n");
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.Object"), 
      Name: "Fusee.Engine.SimpleScene.ShaderCodeBuilder", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm05.TypeRef("Fusee.Serialization.MaterialContainer"), $asm05.TypeRef("Fusee.Serialization.MeshContainer")], []), 
      ShaderCodeBuilder__ctor
    );

    $.Method({Static:false, Public:false}, "AddCameraVec", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_AddCameraVec
    );

    $.Method({Static:false, Public:false}, "AddChannelBaseColorCalculation", 
      new JSIL.MethodSignature(null, [
          $asm07.TypeRef("System.Text.StringBuilder"), $.Boolean, 
          $.String
        ], []), 
      ShaderCodeBuilder_AddChannelBaseColorCalculation
    );

    $.Method({Static:false, Public:false}, "AddDiffuseChannel", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_AddDiffuseChannel
    );

    $.Method({Static:false, Public:false}, "AddEmissiveChannel", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_AddEmissiveChannel
    );

    $.Method({Static:false, Public:false}, "AddLightVec", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_AddLightVec
    );

    $.Method({Static:false, Public:false}, "AddNormalVec", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_AddNormalVec
    );

    $.Method({Static:false, Public:false}, "AddSpecularChannel", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_AddSpecularChannel
    );

    $.Method({Static:false, Public:false}, "AnalyzeMaterial", 
      new JSIL.MethodSignature(null, [$asm05.TypeRef("Fusee.Serialization.MaterialContainer")], []), 
      ShaderCodeBuilder_AnalyzeMaterial
    );

    $.Method({Static:false, Public:false}, "AnalyzeMesh", 
      new JSIL.MethodSignature(null, [$asm05.TypeRef("Fusee.Serialization.MeshContainer")], []), 
      ShaderCodeBuilder_AnalyzeMesh
    );

    $.Method({Static:false, Public:false}, "BumpInputDeclaration", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_BumpInputDeclaration
    );

    $.Method({Static:false, Public:false}, "ChannelInputDeclaration", 
      new JSIL.MethodSignature(null, [
          $asm07.TypeRef("System.Text.StringBuilder"), $.Boolean, 
          $.Boolean, $.String
        ], []), 
      ShaderCodeBuilder_ChannelInputDeclaration
    );

    $.Method({Static:false, Public:true }, "get_BumpIntensityName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_BumpIntensityName
    );

    $.Method({Static:false, Public:true }, "get_BumpTextureName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_BumpTextureName
    );

    $.Method({Static:false, Public:true }, "get_DiffuseColorName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_DiffuseColorName
    );

    $.Method({Static:false, Public:true }, "get_DiffuseMixName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_DiffuseMixName
    );

    $.Method({Static:false, Public:true }, "get_DiffuseTextureName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_DiffuseTextureName
    );

    $.Method({Static:false, Public:true }, "get_EmissiveColorName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_EmissiveColorName
    );

    $.Method({Static:false, Public:true }, "get_EmissiveMixName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_EmissiveMixName
    );

    $.Method({Static:false, Public:true }, "get_EmissiveTextureName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_EmissiveTextureName
    );

    $.Method({Static:true , Public:true }, "get_LightColorName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_LightColorName
    );

    $.Method({Static:true , Public:true }, "get_LightDirectionName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_LightDirectionName
    );

    $.Method({Static:true , Public:true }, "get_LightIntensityName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_LightIntensityName
    );

    $.Method({Static:false, Public:true }, "get_PS", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_PS
    );

    $.Method({Static:false, Public:true }, "get_SpecularColorName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_SpecularColorName
    );

    $.Method({Static:false, Public:true }, "get_SpecularIntensityName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_SpecularIntensityName
    );

    $.Method({Static:false, Public:true }, "get_SpecularMixName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_SpecularMixName
    );

    $.Method({Static:false, Public:true }, "get_SpecularShininessName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_SpecularShininessName
    );

    $.Method({Static:false, Public:true }, "get_SpecularTextureName", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_SpecularTextureName
    );

    $.Method({Static:false, Public:true }, "get_VS", 
      new JSIL.MethodSignature($.String, [], []), 
      ShaderCodeBuilder_get_VS
    );

    $.Method({Static:false, Public:false}, "MatrixDeclarations", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_MatrixDeclarations
    );

    $.Method({Static:false, Public:false}, "MeshInputDeclarations", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_MeshInputDeclarations
    );

    $.Method({Static:false, Public:false}, "PixelInputDeclarations", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_PixelInputDeclarations
    );

    $.Method({Static:false, Public:false}, "PSBody", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_PSBody
    );

    $.Method({Static:false, Public:false}, "SpecularInputDeclaration", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_SpecularInputDeclaration
    );

    $.Method({Static:false, Public:false}, "VSBody", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Text.StringBuilder")], []), 
      ShaderCodeBuilder_VSBody
    );

    $.Field({Static:false, Public:false}, "_hasVertices", $.Boolean); 
    $.Field({Static:false, Public:false}, "_hasNormals", $.Boolean); 
    $.Field({Static:false, Public:false}, "_hasUVs", $.Boolean); 
    $.Field({Static:false, Public:false}, "_hasColors", $.Boolean); 
    $.Field({Static:false, Public:false}, "_hasDiffuse", $.Boolean); 
    $.Field({Static:false, Public:false}, "_hasSpecular", $.Boolean); 
    $.Field({Static:false, Public:false}, "_hasEmissive", $.Boolean); 
    $.Field({Static:false, Public:false}, "_hasBump", $.Boolean); 
    $.Field({Static:false, Public:false}, "_hasDiffuseTexture", $.Boolean); 
    $.Field({Static:false, Public:false}, "_hasSpecularTexture", $.Boolean); 
    $.Field({Static:false, Public:false}, "_hasEmissiveTexture", $.Boolean); 
    $.Field({Static:false, Public:false}, "_normalizeNormals", $.Boolean); 
    $.Field({Static:false, Public:false}, "_vs", $.String); 
    $.Field({Static:false, Public:false}, "_ps", $.String); 
    $.Property({Static:false, Public:true }, "VS", $.String);

    $.Property({Static:false, Public:true }, "PS", $.String);

    $.Property({Static:false, Public:true }, "DiffuseColorName", $.String);

    $.Property({Static:false, Public:true }, "SpecularColorName", $.String);

    $.Property({Static:false, Public:true }, "EmissiveColorName", $.String);

    $.Property({Static:false, Public:true }, "DiffuseTextureName", $.String);

    $.Property({Static:false, Public:true }, "SpecularTextureName", $.String);

    $.Property({Static:false, Public:true }, "EmissiveTextureName", $.String);

    $.Property({Static:false, Public:true }, "BumpTextureName", $.String);

    $.Property({Static:false, Public:true }, "DiffuseMixName", $.String);

    $.Property({Static:false, Public:true }, "SpecularMixName", $.String);

    $.Property({Static:false, Public:true }, "EmissiveMixName", $.String);

    $.Property({Static:false, Public:true }, "SpecularShininessName", $.String);

    $.Property({Static:false, Public:true }, "SpecularIntensityName", $.String);

    $.Property({Static:false, Public:true }, "BumpIntensityName", $.String);

    $.Property({Static:true , Public:true }, "LightDirectionName", $.String);

    $.Property({Static:true , Public:true }, "LightColorName", $.String);

    $.Property({Static:true , Public:true }, "LightIntensityName", $.String);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

